{
    "nodes": [
        {
            "id": "Neighbors1984_Draco",
            "title": "Draco",
            "longtitle": "The Draco approach",
            "description": "The Draco approach to constructing software from reusable components.",
            "hierarchy": [
                "Fundamentals",
                "Feature model's origins"
            ],
            "citations": 480
        },
        {
            "id": "Moore1989_KAPTUR",
            "title": "KAPTUR",
            "longtitle": "The KAPTUR system",
            "description": "The KAPTUR Environment: An Operations Concept. The KAPTUR system used 'distinctive features' to distinguish systems within a domain. Feature-orientation can be traced back to the ROSE tool and the KAPTUR system.",
            "concepts": [
                "Distinctive features"
            ],
            "hierarchy": [
                "Fundamentals",
                "Feature model's origins"
            ]
        },
        {
            "id": "Lubars1988_ROSE",
            "title": "ROSE",
            "longtitle": "The ROSE reuse system",
            "description": "Wide-spectrum support for software reusability.The ROSE tool supported 'feature-based selection' of components. Feature-orientation can be traced back to the ROSE tool and the KAPTUR system.",
            "concepts": [
                "Feature-based selection of components"
            ],
            "hierarchy": [
                "Fundamentals",
                "Feature model's origins"
            ]
        },
        {
            "id": "Biggerstaff1989_ROSE",
            "title": "ROSE",
            "longtitle": "The ROSE reuse system",
            "description": "Design recovery for maintenance and reuse. The ROSE tool supported 'feature-based selection' of components. Feature-orientation can be traced back to the ROSE tool and the KAPTUR system.",
            "concepts": [
                "Feature-based selection of components"
            ],
            "hierarchy": [
                "Fundamentals",
                "Feature model's origins"
            ],
            "citations": 405
        },
        {
            "id": "Batory1988_GENESIS",
            "title": "GENESIS",
            "longtitle": "The GENESIS tool",
            "description": "GENESIS: an extensible database management system.",
            "hierarchy": [
                "Fundamentals",
                "Feature model's origins"
            ],
            "citations": 248
        },
        {
            "id": "Kang1990_FODA",
            "title": "FODA",
            "longtitle": "Feature-Oriented Domain Analysis (FODA)",
            "description": "Feature modeling was originally proposed as part of the Feature-Oriented Domain Analysis (FODA) method. Historically, FODA builds on, among others, Neighbors's work on Draco, and Batory's domain analysis of DBMS and the Genesis tool.",
            "concepts": [
                "Feature model",
                "Feature diagram"
            ],
            "hierarchy": [
                "Fundamentals",
                "Feature model's origins"
            ],
            "citations": 2563
        },
        {
            "id": "Kang1998_FORM",
            "title": "FORM",
            "longtitle": "Feature-Oriented Reuse Method (FORM)",
            "description": "FORM is a feature-oriented reuse method that provides domain-specific reference architectures.",
            "hierarchy": [
                "Fundamentals",
                "FODA extensions"
            ],
            "citations": 1124
        },
        {
            "id": "Griss1998_FeatuRSEB",
            "title": "FeatuRSEB",
            "longtitle": "Reusable Software Engineering Base (FeatuRSEB)",
            "description": "Integrating feature modeling with the RSEB.",
            "hierarchy": [
                "Fundamentals",
                "FODA extensions"
            ],
            "citations": 633
        },
        {
            "id": "Czarnecki2000_GenerativeProgramming",
            "title": "Generative Programming",
            "longtitle": "Generative Programming: Methods, Tools, and Applications",
            "description": "Generative programming is a software engineering paradigm aimed at improving productivity and quality by using automated techniques to generate software artifacts.",
            "hierarchy": [
                "Fundamentals",
                "FODA extensions"
            ]
        },
        {
            "id": "Benavides2005_AutomatedReasoning",
            "title": "Automated Reasoning on FMs",
            "longtitle": "Automated Reasoning on Feature Models",
            "description": "A major historical milestone as the first proposal to successfully model and reason on both functional and extra-functional features (i.e., quality or non-functional features) within a single feature model. Its key importance lies in introducing Constraint Programming (CP) and Constraint Satisfaction Optimization Problems (CSOP) as the formal foundation for automated analysis, alongside Propositional Logic. This work extended traditional FMs to include measurable attributes and attribute-based constraints. Furthermore, it generalized the capabilities of automated reasoning by defining a suite of five core operations (counting, filtering, listing products, validation, and optimization) that were more advanced than previous limited attempts. This established the paradigm for product-line optimization based on quality attributes like cost or development time.",
            "concepts": [
                "Attributed feature models",
                "Extended feature models"
            ],
            "hierarchy": [
                "Automated Analysis",
                "Constraint programming based analyses"
            ],
            "awards": [
                "üèÜMost Influential Paper Award at SPLC 2017"
            ]
        },
        {
            "id": "Batory2004_AHEAD",
            "title": "AHEAD",
            "longtitle": "Feature-oriented programming (FOP) and the AHEAD tool suite",
            "description": "This work focuses on feature-oriented programming and the AHEAD tool suite.",
            "concepts": [
                "Feature-oriented programming (FOP)",
                "AHEAD"
            ],
            "hierarchy": [
                "Variability Implementation",
                "Feature-oriented programming (FOP)"
            ],
            "citations": 219
        },
        {
            "id": "Czarnecki2005_CardinalityFMs",
            "title": "Cardinality-based FMs",
            "longtitle": "Cardinality-based Feature Models",
            "description": "This work focuses on formalizing cardinality-based feature models and their specialization.",
            "concepts": [
                "Cardinality-based feature model"
            ],
            "hierarchy": [
                "Fundamentals",
                "FODA extensions"
            ]
        },
        {
            "id": "Czarnecki2004_StagedConfiguration",
            "title": "Staged Configuration",
            "longtitle": "Staged Configuration of Feature Models",
            "description": "Historically, this work and its journal extension unified and formalized many disparate extensions into the Cardinality-Based Feature Model (CBFM) notation, which integrated feature cardinalities, group cardinalities, attributes, and diagram references. More critically, the work introduced the novel concept of Staged Configuration, acknowledging that in realistic development processes, different groups and roles (e.g., system administrator vs. end-user) eliminate product variability at different times or stages of the product lifecycle. This particular contribution at SPLC 2004 proposed achieving staged configuration through stepwise specialization (transforming a feature model into a less variable feature model).",
            "concepts": [
                "Staged configuration",
                "Stepwise specialization",
                "Cardinality-based feature model"
            ],
            "hierarchy": [
                "Configuration"
            ],
            "awards": [
                "üèÜMost Influential Paper Award at SPLC 2017"
            ],
            "citations": 541
        },
        {
            "id": "Czarnecki2005_StagedConfiguration",
            "title": "Multi-level configuration",
            "longtitle": "Multi-level Configuration of Feature Models",
            "description": "This work extended the Staged Configuration concept with Multilevel Configuration, where separate feature models define the choices for each stage. This multilevel approach was specifically proposed as a solution to avoid \"analysis paralysis\" by separating configuration choices based on abstraction levels.",
            "concepts": [
                "Staged configuration",
                "Multi-level configuration",
                "Cardinality-based feature model"
            ],
            "hierarchy": [
                "Configuration"
            ]
        },
        {
            "id": "Tseng2001_MassCustomization",
            "title": "Mass Customization",
            "longtitle": "Mass Customization",
            "description": "This work focuses on mass customization.",
            "concepts": [
                "Mass customization"
            ],
            "hierarchy": [
                "Software Product Lines"
            ]
        },
        {
            "id": "Clements2001_SPLPracticesAndPatterns",
            "title": "SPLs",
            "longtitle": "Software Product Lines: Practices and Patterns",
            "description": "This work focuses on the practices and patterns in software product lines.",
            "concepts": [
                "Software product line"
            ],
            "hierarchy": [
                "Software Product Lines"
            ]
        },
        {
            "id": "Pohl2005_SPLEngineering",
            "title": "SPL Engineering",
            "longtitle": "Software Product Line Engineering - Foundations, Principles, and Techniques",
            "description": "This work focuses on the foundations, principles, and techniques of software product line engineering.",
            "concepts": [
                "Software product line engineering"
            ],
            "hierarchy": [
                "Software Product Lines"
            ],
            "citations": 2888
        },
        {
            "id": "Greenfield2004_SoftwareFactories",
            "title": "PLUSS",
            "longtitle": "The PLUSS approach",
            "description": "This work focuses on the PLUSS approach to software factories.",
            "concepts": [
                "PLUSS",
                "Software factories"
            ],
            "hierarchy": [
                "Software Product Lines"
            ]
        },
        {
            "id": "Eriksson2005_PLUSS",
            "title": "Software Factories",
            "longtitle": "Software Factories: Assembling Applications with Patterns, Models, Frameworks, and Tools",
            "description": "This work focuses on the assembly of applications using patterns, models, frameworks, and tools.",
            "concepts": [
                "Software factories"
            ],
            "hierarchy": [
                "Software Product Lines"
            ],
            "citations": 174
        },
        {
            "id": "Benavides2010_AAFM20yearsSLR",
            "title": "AAFM",
            "longtitle": "Automated analysis of feature models 20 years later",
            "description": "This is the first comprehensive literature review on the automated analysis of Feature Models (AAFM), covering research from the 20 years following their invention in 1990. Its historical importance lies in its role as a key reference point and conceptual foundation for the AAFM field. The authors synthesized previously disparate streams of work, defined a conceptual framework for the analysis process, and systematically classified 30 operations of analysis (e.g., void models, dead features, optimization) and four groups of automated techniques (i.e., Propositional Logic, Constraint Programming, Description Logic, and Other Analysis Techniques) used in the SPL community. The work also established several open challenges for future research, guiding the community for the next decade.",
            "concepts": [
                "Automated Analysis of Feature Models (AAFM)"
            ],
            "hierarchy": [
                "Automated Analysis"
            ],
            "citations": 1270
        },
        {
            "id": "Batory2005_FMsGrammarsAndPropositionalFormulas",
            "title": "FMs, Grammars, and Propositional Formulas",
            "longtitle": "FMs, Grammars, and Propositional Formulas",
            "description": "Don Batory established a fundamental technical foundation for FMs by formally proving the connection between FMs, grammars, and propositional formulas. This formal equivalence was historically important because it provided a way to leverage mature, efficient tools from the logic and Artificial Intelligence communities to solve FM problems. Specifically, Batory proposed and demonstrated the use of Logic Truth Maintenance Systems (LTMSs) for real-time constraint propagation during product configuration and employed Satisfiability (SAT) solvers for debugging and verifying feature models. This approach established the boolean constraint satisfaction problem as the dominant technical paradigm for automated FM analysis",
            "hierarchy": [
                "Automated Analysis",
                "Propositional logic based analyses"
            ],
            "awards": [
                "üèÜSPLC Test-of-Time Award 2017"
            ],
            "citations": 1353
        },
        {
            "id": "Deursen2002_FDL",
            "title": "FDL",
            "longtitle": "Feature Description Language (FDL)",
            "description": "This is a foundational work that transitioned FMs from a largely informal graphical tool to a formally verifiable and manipulable artifact. Its primary contribution was the proposal of the Feature Description Language (FDL), a textual Domain-Specific Language (DSL) designed to formally capture the variability expressed in Feature Diagrams. The historical significance lies in the introduction of the Feature Diagram Algebra, a suite of formal algebraic rules that enabled automated manipulation and analysis of FMs for the first time. This work established a concrete, tool-supportable approach to FM analysis by defining rules for normalization, variability calculation, and constraint checking.",
            "concepts": [
                "Feature Description Language (FDL)",
                "Feature Diagram Algebra"
            ],
            "hierarchy": [
                "Automated Analysis"
            ],
            "citations": 357
        },
        {
            "id": "Mannion2002_FirstOrderLogic",
            "title": "First-Order Logic",
            "longtitle": "First-Order Logic for FM validation",
            "description": "This is a foundational work that introduced one of the earliest formal, automated methods for validating the consistency of SPL models. Its historical significance lies in establishing the technical paradigm of converting the complex dependency and variability relationships (like mutual exclusion or alternatives) into a single Propositional Logic expression. This technique allowed the automated verification of model properties, such as checking for void models (i.e., whether at least one valid system can be selected), and the validation of specific product configurations by using propositional calculus. Furthermore, the work formally posed key questions that later became the standard automated analysis operations in the FM community (e.g., product counting, product listing).",
            "hierarchy": [
                "Automated Analysis",
                "Propositional logic based analyses"
            ],
            "citations": 262
        },
        {
            "id": "Prehofer1997_FOP",
            "title": "FOP",
            "longtitle": "Feature-Oriented Programming (FOP)",
            "description": "This milestone marks the introduction and formalization of Feature-Oriented Programming (FOP). This work first proposed the concept, defining features as fine-grained increments of functionality similar to (abstract) subclasses but focused on the core functionality, with feature interactions (method overwrites) being specified separately. The core idea was to enable an exponential number of product combinations from a base set of features and quadratic interaction resolutions, going beyond standard object-oriented composition mechanisms like inheritance.",
            "concepts": [
                "Feature-oriented programming (FOP)"
            ],
            "hierarchy": [
                "Variability Implementation",
                "Composition-based approaches",
                "Feature-oriented programming (FOP)"
            ],
            "awards": [
                "üèÜMost Influential Paper Award at SPLC 2018"
            ],
            "citations": 524
        },
        {
            "id": "Prehofer2001_FOP",
            "title": "FOP",
            "longtitle": "Feature-Oriented Programming (FOP)",
            "description": "This work extended and formalized the Feature-Oriented Programming (FOP) model, specifically introducing explicit interaction handlers to adapt features and address the feature interaction problem systematically. Historically, this work is crucial as it connected feature models from the domain analysis phase (variability modeling) directly to the implementation phase (code composition), establishing one of the major paradigms, alongside Aspect-Oriented Programming (AOP), for realizing software product lines at the source code level.",
            "concepts": [
                "Feature-oriented programming (FOP)"
            ],
            "hierarchy": [
                "Variability Implementation",
                "Composition-based approaches",
                "Feature-oriented programming (FOP)"
            ],
            "awards": [
                "üèÜMost Influential Paper Award at SPLC 2018"
            ],
            "citations": 44
        },
        {
            "id": "K√§stner2008_CIDE",
            "title": "CIDE",
            "longtitle": "Granularity in Software Product Lines with Colored IDE (CIDE)",
            "description": "This work addressed the critical gap between Feature Models (specifying variability at an abstract level) and Feature Implementation (realizing variability in code). Historically, existing implementation approaches (like FOP, AOP, or C-preprocessor) primarily supported coarse-grained features (e.g., adding/wrapping entire classes or methods). This work showed that fine-grained extensions (e.g., adding a single statement or expression inside a method body) are essential, particularly when extracting features from legacy systems or for minimizing code replication. The key contribution was the introduction of Colored IDE (CIDE), a tool that allowed developers to implement both coarse and fine-grained extensions in a clean, concise, and separated manner by coloring code elements according to the feature they belong to. CIDE thus offered a fundamental implementation mechanism that directly supported the full variability complexity captured in Feature Models.",
            "concepts": [
                "Feature Granularity, Colored IDE (CIDE)"
            ],
            "hierarchy": [
                "Variability Implementation"
            ],
            "awards": [
                "üèÜMost Influential Paper Award at SPLC 2019"
            ],
            "citations": 505
        },
        {
            "id": "Smaragdakis2002_MixinLayers",
            "title": "Mixin Layers",
            "longtitle": "Mixin Layers",
            "description": "This work introduced Mixin Layers as a robust, object-oriented technique for implementing large-scale refinements and collaboration-based designs. Its historical importance is that it provided one of the most powerful and flexible mechanisms for realizing the variability captured in Feature Models at the source code level, offering a practical alternative to Aspect-Oriented Programming (AOP) and earlier feature-oriented approaches. A Mixin Layer is a collection of classes that together implement a feature or refinement, and they are composable in a sequence (a stack) to build the final product. The composition mechanism, which avoids class-naming conflicts, allows for non-invasive feature addition and provides a clean separation of concerns, thereby directly supporting the principles of Software Product Line engineering.",
            "concepts": [
                "Mixin Layers",
                "Refinements as Layers",
                "Collaboration-Based Design",
                "Non-Invasive Composition"
            ],
            "hierarchy": [
                "Variability Implementation",
                "Composition-based approaches"
            ],
            "citations": 364
        },
        {
            "id": "Apel2008_AspectualFeatureModules",
            "title": "Aspectual Feature Modules",
            "longtitle": "Aspectual Feature Modules",
            "description": "This work is a significant milestone that unified the two dominant variability realization paradigms: Feature-Oriented Programming (FOP) and Aspect-Oriented Programming (AOP). Historically, FOP (using Feature Modules) was excellent for implementing coarse-grained, compositional software blocks, while AOP (using Aspects) was essential for modularizing fine-grained, crosscutting concerns (e.g., logging, security) that scatter across multiple modules. This work systematically evaluated the strengths and weaknesses of both, concluding that they are complementary. The key contribution was the introduction of Aspectual Feature Modules (AFMs), a novel programming technique that integrates Feature Modules and Aspects into a unified construct. This provided software product line (SPL) developers with a single, comprehensive mechanism to implement both the large-scale feature logic (the FOP part) and the pervasive, non-functional requirements (the AOP part), thereby improving modularity and maintainability in SPLs.",
            "concepts": [
                "Aspectual Feature Modules",
                "Complementarity of FOP and AOP",
                "Holistic Variability Realization"
            ],
            "hierarchy": [
                "Variability Implementation",
                "Composition-based approaches"
            ],
            "citations": 190
        },
        {
            "id": "Kiczales1997_AOP",
            "title": "AOP",
            "longtitle": "Aspect-Oriented Programming (AOP)",
            "description": "This work introduced the concept of Aspect-Oriented Programming (AOP) and the first implementation in the AspectJ language. Its historical significance for Feature Models (FMs) is profound: it provided the second major technical solution (alongside Feature-Oriented Programming) for the realization of variability in Software Product Lines (SPLs) at the code level. The core concept is the crosscutting concern (an aspect), which is a design decision (like logging, synchronization, or security) whose implementation logically belongs to a single module but is physically scattered across many parts of the system's core functionality (the base code). AOP allowed developers to modularize these crosscutting features, thus directly supporting the implementation of features that require modifications to many different parts of a software product line. This capability was later integrated with FOP to create unified realization techniques.",
            "concepts": [
                "Aspect-Oriented Programming (AOP)",
                "Aspects",
                "Crosscutting Concerns",
                "Tangled Code",
                "Join Point Model"
            ],
            "hierarchy": [
                "Variability Implementation",
                "Composition-based approaches",
                "Aspect-Oriented Programming (AOP)"
            ],
            "citations": 0
        },
        {
            "id": "Classen2010_TemporalPropertiesSPLs",
            "title": "Model Checking SPLs",
            "longtitle": "Efficient Verification of Temporal Properties in SPLs",
            "description": "A major historical advance in the formal verification of Software Product Lines (SPLs). Given that the number of products in an SPL can be exponential in the number of features (the \"combinatorial explosion\" problem), previous approaches to verify system behavior (e.g., model checking each product individually) were not scalable. This work's historical importance is that it introduced a scalable technique for verifying temporal properties (e.g., \"The system will eventually reach a safe state\") across the entire family of systems simultaneously. The key was to extend transition systems with features (Feature-Oriented Transition Systems) and apply a specialized lifted model checking algorithm. This allowed checking a single compact model, rather than 2N product-specific models, making the formal verification of system behavior in industrial-scale SPLs feasible for the first time.",
            "concepts": [
                "Feature-Oriented Transition Systems (FOTS)",
                "Lifted Model Checking",
                "Behavioral Verification"
            ],
            "hierarchy": [
                "Automated Analysis",
                "Formal Verification"
            ],
            "awards": [
                "üèÜMost Influential Paper Award at SPLC 2020"
            ],
            "citations": 371
        },
        {
            "id": "Schaefer2010_DOP",
            "title": "DOP",
            "longtitle": "Delta-Oriented Programming (DOP)",
            "description": "This work introduced Delta-Oriented Programming (DOP) as a novel, fundamental paradigm for implementing Software Product Lines (SPLs), offering an alternative to the compositional approach of Feature-Oriented Programming (FOP). Historically, FOP relied on extending existing code by stacking feature modules. DOP, by contrast, relies on a core module (a valid product) and a set of delta modules that specify additive, modificatory, and removal changes to the core code. This historical shift provides greater flexibility, as it supports modifications and removals that are cumbersome in purely compositional FOP approaches. Products are derived by applying a sequence of delta modules based on the feature configuration. DOP is particularly valuable for SPLs derived from legacy or existing single-application systems because it aligns closely with the patching/refactoring nature of such evolution.",
            "concepts": [
                "Delta-Oriented Programming (DOP)",
                "Core Module",
                "Delta Modules",
                "Application Conditions"
            ],
            "hierarchy": [
                "Variability Implementation",
                "Composition-based approaches",
                "Delta-Oriented Programming (DOP)"
            ],
            "awards": [
                "üèÜMost Influential Paper Award at SPLC 2022"
            ],
            "citations": 408
        },
        {
            "id": "Perrouin2010_TWiseTestCaseGeneration",
            "title": "T-wise Testing",
            "longtitle": "T-wise Test Case Generation",
            "description": "A foundational work in the testing and quality assurance of Software Product Lines (SPLs). Given the combinatorial explosion problem‚Äîwhere an SPL can have thousands or millions of valid products‚Äîexhaustive testing is infeasible. This work popularized the use of T-wise combinatorial testing as a practical and effective strategy for SPL validation. T-wise testing generates a small, representative subset of products that guarantees coverage of all possible interactions between T features. The historical importance of the paper lies in addressing the scalability and automation challenges of this method. It proposes and implements a toolset that uses the Alloy constraint solver to automatically generate T-wise test cases from Feature Models, and, critically, introduces strategies to split large T-wise combinations into solvable subsets to overcome the memory and time limitations of SAT solvers (\"all-at-once\" failure).",
            "concepts": [
                "T-wise Combinatorial Testing for SPLs",
                "Alloy-Based Test Generation",
                "Scalability Strategies",
                "Metrics for Evaluation"
            ],
            "hierarchy": [
                "Software Product Lines",
                "Testing"
            ],
            "awards": [
                "üèÜMost Influential Paper Award at SPLC 2024"
            ],
            "citations": 226
        },
        {
            "id": "Thum2009_ReasoningAboutEditsToFMs",
            "title": "Refactoring",
            "longtitle": "Reasoning about Edits to Feature Models",
            "description": "This work addresses the critical and practical problem of Feature Model (FM) evolution. Since Software Product Lines (SPLs) and their models evolve continuously, designers need to understand and control how modifications to an FM affect the set of valid products (the product space). The historical importance of this work lies in providing the first formal and efficient framework for reasoning about and classifying FM edits. The authors defined a taxonomy of edits (refactorings, specializations, generalizations, and arbitrary edits) based on whether the edit preserves, reduces, or expands the product space. Most crucially, they presented an algorithm that automatically takes two FMs (before and after edit) as input and efficiently computes the classification and determines the set of added or deleted products, even for large models with thousands of features. This capability provided essential tool support for maintaining consistency and coherence during SPL evolution.",
            "concepts": [
                "FM Edit Taxonomy",
                "Refactoring",
                "Specialization",
                "Generalization",
                "Change Reasoning Algorithm",
                "Automated Coherence Management"
            ],
            "hierarchy": [
                "Evolution"
            ],
            "awards": [
                "üèÜMost Influential Paper Award at SPLC 2023"
            ],
            "citations": 381
        },
        {
            "id": "Zhang2004_EquivalentFeatures",
            "title": "Equivalent Features",
            "longtitle": "Equivalent Features (Precursor to Atomic Sets)",
            "description": "This milestone focuses on the Atomic Set (AS) concept, a fundamental technique for simplifying Feature Models and improving the scalability of automated analysis. Zhang et al. first introduced the concept, implicitly recognizing that in any valid product configuration, certain features are always selected together or never selected at all. These sets of features that behave identically across all valid products were termed Equivalent Features and served as the foundational idea for Atomic Sets.",
            "concepts": [
                "Equivalent Features"
            ],
            "hierarchy": [
                "Automated Analysis",
                "Analysis Operations"
            ],
            "citations": 0
        },
        {
            "id": "Segura2008_AtomicSets",
            "title": "Atomic Sets",
            "longtitle": "Atomic Sets",
            "description": "S. Segura formalized and popularized the term Atomic Sets, proposing them as a generic technique for FM simplification. Its key contribution was to explicitly set the basis for the usage of Atomic Sets by defining specific algorithms and providing the first empirical evidence of their effectiveness in reducing the size of the propositional logic formula, thereby dramatically improving the performance of SAT-based analysis tools. The relationship between this contribution and its predecessor is that Zhang's work established the core idea (Equivalent Features), which Segura later formalized, named, and validated as a practical, scalable analysis technique (Atomic Sets).",
            "concepts": [
                "Atomic Sets",
                "FM Simplification/Variable Reduction",
                "Scalability for Automated Analysis"
            ],
            "hierarchy": [
                "Automated Analysis",
                "Analysis Operations"
            ],
            "citations": 0
        }
    ],
    "links": [
        {
            "source": "Neighbors1984_Draco",
            "target": "Kang1990_FODA"
        },
        {
            "source": "Batory1988_GENESIS",
            "target": "Kang1990_FODA"
        },
        {
            "source": "Lubars1988_ROSE",
            "target": "Biggerstaff1989_ROSE"
        },
        {
            "source": "Biggerstaff1989_ROSE",
            "target": "Kang1990_FODA"
        },
        {
            "source": "Moore1989_KAPTUR",
            "target": "Kang1990_FODA"
        },
        {
            "source": "Kang1990_FODA",
            "target": "Kang1998_FORM"
        },
        {
            "source": "Kang1990_FODA",
            "target": "Griss1998_FeatuRSEB"
        },
        {
            "source": "Kang1990_FODA",
            "target": "Czarnecki2000_GenerativeProgramming"
        },
        {
            "source": "Clements2001_SPLPracticesAndPatterns",
            "target": "Greenfield2004_SoftwareFactories"
        },
        {
            "source": "Greenfield2004_SoftwareFactories",
            "target": "Pohl2005_SPLEngineering"
        },
        {
            "source": "Tseng2001_MassCustomization",
            "target": "Greenfield2004_SoftwareFactories"
        },
        {
            "source": "Clements2001_SPLPracticesAndPatterns",
            "target": "Greenfield2004_SoftwareFactories"
        },
        {
            "source": "Griss1998_FeatuRSEB",
            "target": "Eriksson2005_PLUSS"
        },
        {
            "source": "Batory2005_FMsGrammarsAndPropositionalFormulas",
            "target": "Benavides2010_AAFM20yearsSLR"
        },
        {
            "source": "Benavides2005_AutomatedReasoning",
            "target": "Benavides2010_AAFM20yearsSLR"
        },
        {
            "source": "Mannion2002_FirstOrderLogic",
            "target": "Batory2005_FMsGrammarsAndPropositionalFormulas"
        },
        {
            "source": "Deursen2002_FDL",
            "target": "Benavides2005_AutomatedReasoning"
        },
        {
            "source": "Mannion2002_FirstOrderLogic",
            "target": "Benavides2005_AutomatedReasoning"
        },
        {
            "source": "Czarnecki2004_StagedConfiguration",
            "target": "Czarnecki2005_StagedConfiguration"
        },
        {
            "source": "Czarnecki2000_GenerativeProgramming",
            "target": "Czarnecki2004_StagedConfiguration"
        },
        {
            "source": "Czarnecki2000_GenerativeProgramming",
            "target": "Czarnecki2005_CardinalityFMs"
        },
        {
            "source": "Prehofer1997_FOP",
            "target": "Prehofer2001_FOP"
        },
        {
            "source": "Prehofer2001_FOP",
            "target": "Batory2004_AHEAD"
        },
        {
            "source": "Batory2004_AHEAD",
            "target": "K√§stner2008_CIDE"
        },
        {
            "source": "Smaragdakis2002_MixinLayers",
            "target": "K√§stner2008_CIDE"
        },
        {
            "source": "Apel2008_AspectualFeatureModules",
            "target": "K√§stner2008_CIDE"
        },
        {
            "source": "Kiczales1997_AOP",
            "target": "K√§stner2008_CIDE"
        },
        {
            "source": "Zhang2004_EquivalentFeatures",
            "target": "Segura2008_AtomicSets"
        }
    ]
}